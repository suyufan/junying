declare class ByteUtil {
    ESPTOUCH_ENCODING_CHARSET: string;
    toInt8Array(bytes: any): any;
    toUint8Array(bytes: any): any;
    stringToByteArray(str: any): any[];
    /**
     * Put String to byte[]
     *
     * @param destbytes  the byte[] of dest
     * @param srcString  the String of src
     * @param destOffset the offset of byte[]
     * @param srcOffset  the offset of String
     * @param count      the count of dest, and the count of src as well
     */
    putString2bytes(destbytes: any, srcString: any, destOffset: any, srcOffset: any, count: any): void;
    /**
     * Convert uint8 into char( we treat char as uint8)
     *
     * @param uint8 the unit8 to be converted
     * @return the byte of the unint8
     */
    convertUint8toByte(uint8: any): number;
    /**
     * Convert byte[] into char[]( we treat char[] as uint8[])
     *
     * @param uint8 the byte[] to be converted
     * @return the bytes[](uint8[])
     */
    convertUnit8s2Bytes(uint8s: any): Int8Array;
    convertNumberToChar(num: any): number;
    convertNumberToByte(num: any): number;
    /**
     * Convert char into uint8( we treat char as uint8 )
     *
     * @param b the byte to be converted
     * @return the char(uint8)
     */
    convertByte2Uint8(b: any): number;
    /**
     * Convert byte[] into char[]( we treat char[] as uint8[])
     *
     * @param bytes the byte[] to be converted
     * @return the char[](uint8[])
     */
    convertBytes2Uint8s(bytes: any): Uint8Array;
    /**
     * Put byte[] into char[]( we treat char[] as uint8[])
     *
     * @param destUint8s the char[](uint8[]) array
     * @param srcBytes   the byte[]
     * @param destOffset the offset of char[](uint8[])
     * @param srcOffset  the offset of byte[]
     * @param count      the count of dest, and the count of src as well
     */
    putbytes2Uint8s(destUint8s: any, srcBytes: any, destOffset: any, srcOffset: any, count: any): void;
    byteToHex(byte: any): string;
    byteArrayToString(bytes: any): any;
    /**
     * Turns an array of numbers into the hex string given by the concatenation of
     * the hex values to which the numbers correspond.
     * @param {Uint8Array|Array<number>} array Array of numbers representing
     *     characters.
     * @param {string=} optSeparator Optional separator between values
     * @return {string} Hex string.
     */
    byteArrayToHex(array: any, optSeparator?: string): string;
    /**
     * Convert byte to Hex String
     *
     * @param b the byte to be converted
     * @return the Hex String
     */
    convertByte2HexString(b: any): string;
    /**
     * Convert char(uint8) to Hex String
     *
     * @param u8 the char(uint8) to be converted
     * @return the Hex String
     */
    convertU8ToHexString(u8: any): string;
    /**
     * Split uint8 to 2 bytes of high byte and low byte. e.g. 20 = 0x14 should
     * be split to [0x01,0x04] 0x01 is high byte and 0x04 is low byte
     *
     * @param uint8 the char(uint8)
     * @return the high and low bytes be split, byte[0] is high and byte[1] is
     * low
     */
    splitUint8To2bytes(uint8: any): any[];
    /**
     * Combine 2 bytes (high byte and low byte) to one whole byte
     *
     * @param high the high byte
     * @param low  the low byte
     * @return the whole byte
     */
    combine2bytesToOne(high: any, low: any): number;
    /**
     * Combine 2 bytes (high byte and low byte) to
     *
     * @param high the high byte
     * @param low  the low byte
     * @return the char(u8)
     */
    combine2bytesToU16(high: any, low: any): number;
    getSpecBytesFromChar(len: any): Int8Array;
    /**
     * Generate the specific byte to be sent
     *
     * @param len the len presented by byte
     * @return the byte[]
     */
    genSpecBytes(len: any): Int8Array;
    parseBssid(bssidBytes: any): string;
    /**
     * parse "24,-2,52,-102,-93,-60" to "18,fe,34,9a,a3,c4"
     * parse the bssid from hex to String
     *
     * @param bssidBytes the hex bytes bssid, e.g. {24,-2,52,-102,-93,-60}
     * @return the String of bssid, e.g. 18fe349aa3c4
     */
    getParsedBssid(bssidBytes: any): string;
    /**
     * parse bssid
     *
     * @param bssid the bssid like aa:bb:cc:dd:ee:ff
     * @return byte converted from bssid
     */
    parseBssid2bytes(bssid: any): Int8Array;
    getStringBytesLength(str: any): number;
    stringToUtf8ByteArray(str: any): Int8Array;
    utf8ByteArrayToString(bytes: any): string;
    /**
     * @param string the string to be used
     * @return the byte[] of String according to {@link #ESPTOUCH_ENCODING_CHARSET}
     */
    getBytesByString(string: any): Int8Array;
    hexStringToByteArray(s: any): any[];
    hexString2hexArray(hexString?: string): RegExpMatchArray;
    hexArray2Float32(hexArray: any, fixedLength: any): string | number;
    float32ToHexArray(float: any): RegExpMatchArray;
    hex2Int32(s: any): number;
    int32ToHex(int32: any): string;
    arrayCopy(srcPts: any, srcOff: any, dstPts: any, dstOff: any, size: any): void;
    crc8Byte(c: any): number;
    crc8Bytes(bs: any, len: any): number;
    base64Encode(string: any): string;
    testSplitUint8To2bytes(): void;
    testCombine2bytesToOne(): void;
    testConvertChar2Uint8(): void;
    testConvertUint8toByte(): void;
    testParseBssid(): void;
    testMain(): void;
}
export declare const byteUtil: ByteUtil;
export {};
