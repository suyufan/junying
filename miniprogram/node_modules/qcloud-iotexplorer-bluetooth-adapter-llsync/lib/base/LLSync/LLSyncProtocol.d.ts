import { LLSyncDeviceAdapter } from './LLSyncDeviceAdapter';
import { Action } from '../../libs';
export interface WriteStampResult {
    sign: string;
    timestamp: number;
    nonce: number;
    deviceName: string;
    userCheckResult?: boolean;
}
export interface RegisterDeviceInfoResult {
    sign: string;
    deviceName: string;
}
export interface WriteConInfoResult {
    sign: string;
    timestamp: number;
}
export declare enum BindState {
    /** 未绑定 */
    NOT_BOUND = 0,
    /** 绑定中 */
    WAITING_BIND = 1,
    /** 已绑定 */
    HAS_BOUND = 2,
    /** 已连接 */
    CONNECTED = 3
}
export interface AdvertisingData {
    bindState: BindState;
    isEncrypted: boolean;
    isDynamicRegister: boolean;
    moduleVersion: number;
    macAddress?: string;
    productId?: string;
    deviceIdentify?: string;
    deviceUserIdentify?: string;
}
export declare const LLSyncConfig: {
    BLE_PSK_DEVICE_KEY: string;
    Secret_Encrypt_Key: string;
    waitConnectReplyTime: number;
    waitBindReplyTime: number;
    waitGetRegisterDeviceInfo: number;
    waitGetCheckTimeoutReplyTime: number;
    waitGetCheckTimeoutDefaultReplyTime: number;
    waitControlReplyTime: number;
    waitGetDeviceInfoTime: number;
    waitUpdateReplyInt: number;
    waitGetAdvDataReplyTime: number;
    mtuDefaultMap: {
        0: any;
        1: number;
        2: number;
    };
};
export declare class LLSyncProtocol {
    deviceAdapter: LLSyncDeviceAdapter;
    _cleanupUserCheckHandleAfterCancel: () => void;
    get reporter(): import("qcloud-iotexplorer-appdev-sdk").Reporter;
    constructor(deviceAdapter: LLSyncDeviceAdapter);
    /**
     * 请求绑定，写入时间戳，换取获取设备签名
     */
    requestBindDevice({ needUserCheck, isDynamicRegister, }: {
        needUserCheck: boolean;
        isDynamicRegister: boolean;
    }): Promise<WriteStampResult>;
    registerDevice({ timestamp, nonce, bindDeviceData, }: {
        timestamp: any;
        nonce: any;
        bindDeviceData: any;
    }): Promise<{
        bleData: string[];
        timestamp: number;
    }>;
    bindDeviceDirectly({ bindDeviceData, dataHandler, }: {
        bindDeviceData: any;
        dataHandler: any;
    }): Promise<WriteStampResult>;
    /**
   * 需要用户确认的绑定流程：
   * 1. 请求绑定
   * 2. 等待设备响应用户确认超时时间（老固件不会响应），若响应则设置用户超时定时器，超时未响应则设置默认超时时间
   * 3. 等待用户确认
   *
   * Checklist：
   * 1. 老版本固件，不返回超时时间（用错误的事件来模拟），能够设置默认的用户确认超时
   * 2. 正常固件，及时返回超时时间，设置正确的用户确认超时
   * 3. 用户UI上主动拒绝绑定，能够正确取消
   * 4. 用户设备上主动拒绝绑定，能够正确取消
   * 5. 不做任何响应，能够正确超时
   * 6. 用户正常确认，能够正常绑定
   */
    waitUserCheckAndBindDevice({ bindDeviceData, dataHandler, }: {
        bindDeviceData: any;
        dataHandler: any;
    }): Promise<WriteStampResult>;
    cancelUserCheck(reason?: 'timeout' | 'cancel'): void;
    getDeviceAuthInfo(): Promise<WriteConInfoResult>;
    getDeviceInfo(): Promise<{
        version: number;
        mtu: number;
        needSetMtu: boolean;
        otaVersion: string;
    }>;
    getUnbindAuthSign(): Promise<{
        sign: string;
    }>;
    controlDeviceAction(action: Action): Promise<{
        success: boolean;
        output: string[];
    }>;
    controlDeviceProperty(properties: any): Promise<{
        code: number;
    }>;
    /**
     * 各类响应
     */
    reportBindSuccess(bindStartTime: any): Promise<string>;
    reportBindEncryptedSuccess(bindStartTime: any, secretkey: any): Promise<{
        ack: number;
        errCode: any;
    }>;
    reportBindError(code?: string): void;
    reportBindEncryptedError(secretkey: any): void;
    reportConnectError(): void;
    reportPropertyReportResult(code?: number): void;
    reportEventReportResult(code: number, eventIndex: any): void;
    reportGetStatusResult(code?: number, tlvData?: any, tmpData?: any): void;
    reportUnbindResult(mode: 'success' | 'fail'): Promise<void>;
    notifyAppReady(): Promise<void>;
    notifyAppOnIOSDevice(): Promise<void>;
    notifyLocalRssi({ rssi }: {
        rssi: number;
    }): Promise<never>;
    sendHeartbeat(): Promise<void>;
    getAdvertisingData(): Promise<AdvertisingData>;
    /**
     * Helpers
     */
    _parseDataBeforeConnect(data: any, mode: any): string[];
}
export declare const isHeartbeatResp: (hex: string[]) => boolean;
